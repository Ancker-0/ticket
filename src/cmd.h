/**
 * For dispatching commands
 *
 * This file was generated by Chez Scheme
 * Generated at "Wed May 21 21:53:56 2025"
 *
 * 2025 Â© Coffish
 **/

#ifndef CMD_H
#define CMD_H

#include <cassert>
#include <iostream>
#include <string>

#include "account.h"
#include "typedecl.h"
#include "vector.h"
// #include <vector>
// namespace sjtu {
//   template <typename T> using vector = std::vector<T>;
// };

std::string add_user_handler([[maybe_unused]] const std::string &gc,
                             [[maybe_unused]] const std::string &gu,
                             [[maybe_unused]] const std::string &gp,
                             [[maybe_unused]] const std::string &gn,
                             [[maybe_unused]] const std::string &gm,
                             [[maybe_unused]] const std::string &gg) {
  // TODO: no check -c and -g for the first user
  if (not(((username_checker(gc)) && (username_checker(gu)) &&
           (password_checker(gp)) && (realname_checker(gn)) &&
           (mail_checker(gm)) && (privilege_checker(gg)))))
    return "-1";
  return accounter.add_user(username_converter(gc),
                            user_profile(gu, gp, gn, gm, gg))
             ? "0"
             : "-1";
}

std::string login_handler([[maybe_unused]] const std::string &gu,
                          [[maybe_unused]] const std::string &gp) {
  if (not(((username_checker(gu)) && (password_checker(gp))))) return "-1";
  return accounter.login(username_converter(gu), password_converter(gp)) ? "0"
                                                                         : "-1";
}

std::string logout_handler([[maybe_unused]] const std::string &gu) {
  if (not(((username_checker(gu))))) return "-1";
  return accounter.logout(username_converter(gu)) ? "0" : "-1";
}

std::string query_profile_handler([[maybe_unused]] const std::string &gc,
                                  [[maybe_unused]] const std::string &gu) {
  if (not(((username_checker(gc)) && (username_checker(gu))))) return "-1";
  try {
    user_profile prof =
        accounter.query_profile(username_converter(gc), username_converter(gu));
    if (gc == "Savage" and gu == "Catapult")
      std::cerr << "! " << (std::string)accounter.db.get(username_converter(gc))
                << '\n'
                << (std::string)accounter.db.get(username_converter(gu))
                << std::endl;
    return (std::string)prof;
  } catch (const Error &e) {
    return "-1";
  }
  return assert(false), "-1";
}

std::string modify_profile_handler([[maybe_unused]] const std::string &gc,
                                   [[maybe_unused]] const std::string &gu,
                                   [[maybe_unused]] const std::string &gp,
                                   [[maybe_unused]] const std::string &gn,
                                   [[maybe_unused]] const std::string &gm,
                                   [[maybe_unused]] const std::string &gg) {
  if (not(((username_checker(gc)) && (username_checker(gu))))) return "-1";
  if (not(((((((gp) == (""))) || (password_checker(gp)))) &&
           (((((gn) == (""))) || (realname_checker(gn)))) &&
           (((((gm) == (""))) || (mail_checker(gm)))) &&
           (((((gg) == (""))) || (privilege_checker(gg)))))))
    return "-1";
  try {
    user_profile prof = accounter.modify_profile(
        username_converter(gc), username_converter(gu), gp, gn, gm, gg);
    return (std::string)prof.username + " " + (std::string)prof.realname + " " +
           (std::string)prof.mail + " " + number2string(prof.privilege);
  } catch (const Error &) {
    return "-1";
  }
  return assert(false), "-1";
}

std::string add_train_handler([[maybe_unused]] const std::string &gi,
                              [[maybe_unused]] const std::string &gn,
                              [[maybe_unused]] const std::string &gm,
                              [[maybe_unused]] const std::string &gs,
                              [[maybe_unused]] const std::string &gp,
                              [[maybe_unused]] const std::string &gx,
                              [[maybe_unused]] const std::string &gt,
                              [[maybe_unused]] const std::string &go,
                              [[maybe_unused]] const std::string &gd,
                              [[maybe_unused]] const std::string &gy) {
  train_t train(gi, gn, gs, gm, gp, gx, gt, go, gd, gy);
  return "sorry, not implemented!";
}

std::string delete_train_handler([[maybe_unused]] const std::string &gi) {
  return "sorry, not implemented!";
}

std::string release_train_handler([[maybe_unused]] const std::string &gi) {
  return "sorry, not implemented!";
}

std::string query_train_handler([[maybe_unused]] const std::string &gi,
                                [[maybe_unused]] const std::string &gd) {
  return "sorry, not implemented!";
}

std::string query_ticket_handler([[maybe_unused]] const std::string &gs,
                                 [[maybe_unused]] const std::string &gt,
                                 [[maybe_unused]] const std::string &gd,
                                 [[maybe_unused]] const std::string &gp) {
  return "sorry, not implemented!";
}

std::string query_transfer_handler([[maybe_unused]] const std::string &gs,
                                   [[maybe_unused]] const std::string &gt,
                                   [[maybe_unused]] const std::string &gd,
                                   [[maybe_unused]] const std::string &gp) {
  return "sorry, not implemented!";
}

std::string buy_ticket_handler([[maybe_unused]] const std::string &gu,
                               [[maybe_unused]] const std::string &gi,
                               [[maybe_unused]] const std::string &gd,
                               [[maybe_unused]] const std::string &gn,
                               [[maybe_unused]] const std::string &gf,
                               [[maybe_unused]] const std::string &gt,
                               [[maybe_unused]] const std::string &gq) {
  return "sorry, not implemented!";
}

std::string query_order_handler([[maybe_unused]] const std::string &gu) {
  return "sorry, not implemented!";
}

std::string refund_ticket_handler([[maybe_unused]] const std::string &gu,
                                  [[maybe_unused]] const std::string &gn) {
  return "sorry, not implemented!";
}

std::string clean_handler() { return "sorry, not implemented!"; }

std::string exit_handler() { return "bye"; }

std::string dispatch(std::string line) {
  long long time = 0;

#if WEAK_TIME
  int p = 0;
  if (line[0] == '[') {
    assert(line.size() and line[0] == '[');
    p = 1;
    for (; p < (int)line.size(); ++p) {
      if ('0' <= line[p] and line[p] <= '9')
        time = time * 10 + line[p] - '0';
      else if (line[p] == ']')
        break;
      else
        assert(false);
    }
    assert(p + 1 < (int)line.size() and line[p] == ']' and line[p + 1] == ' ');
    ++p;
  } else
    time = -1;
#else
  assert(line.size() and line[0] == '[');
  int p = 1;
  for (; p < (int)line.size(); ++p) {
    if ('0' <= line[p] and line[p] <= '9')
      time = time * 10 + line[p] - '0';
    else if (line[p] == ']')
      break;
    else
      assert(false);
  }
  assert(p + 1 < (int)line.size() and line[p] == ']' and line[p + 1] == ' ');
  ++p;
#endif

  std::string time_str = "[" + number2string(time) + "] ";

  while (p < (int)line.size() and line[p] == ' ') ++p;
  std::string cmd = ({
    std::string tmp;
    while (p < (int)line.size() and line[p] == ' ') ++p;
    while (!(p >= (int)line.size()) and line[p] != ' ') {
      tmp += line[p++];
    }
    tmp;
  });

  sjtu::vector<std::pair<std::string, std::string>> kvpair;
  while (p < (int)line.size()) {
    while (p < (int)line.size() and line[p] == ' ') ++p;
    if ((p >= (int)line.size())) break;
    assert(p + 2 < (int)line.size() and line[p] == '-' and line[p + 2] == ' ');
    std::string k(1, line[p + 1]), v = "";
    p += 2;
    while (p < (int)line.size() and line[p] == ' ') ++p;
    while (!(p >= (int)line.size()) and line[p] != ' ') v += line[p++];
    kvpair.push_back({k, v});
  }

  // for (auto [k, v] : kvpair)
  //   printf("%s => %s\n", k.data(), v.data());

  // sjtu::vector<std::string> values;
  // for (auto &[k, v] : kvpair)
  //   if (k == "a")
  //     values.push_back(v);
  // assert(values.size() <= 1);
  // arguments.push_back(values[0]);

  if (((cmd) == ("exit"))) {
    sjtu::vector<std::string> arguments;
    return time_str + exit_handler();
  } else if (((cmd) == ("clean"))) {
    sjtu::vector<std::string> arguments;
    return time_str + clean_handler();
  } else if (((cmd) == ("refund_ticket"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "n") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    return time_str + refund_ticket_handler(arguments[0], arguments[1]);
  } else if (((cmd) == ("query_order"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + query_order_handler(arguments[0]);
  } else if (((cmd) == ("buy_ticket"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "i") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "d") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "n") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "f") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "t") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "q") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    return time_str + buy_ticket_handler(arguments[0], arguments[1],
                                         arguments[2], arguments[3],
                                         arguments[4], arguments[5],
                                         arguments[6]);
  } else if (((cmd) == ("query_transfer"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "s") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "t") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "d") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "p") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    return time_str + query_transfer_handler(arguments[0], arguments[1],
                                             arguments[2], arguments[3]);
  } else if (((cmd) == ("query_ticket"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "s") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "t") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "d") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "p") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    return time_str + query_ticket_handler(arguments[0], arguments[1],
                                           arguments[2], arguments[3]);
  } else if (((cmd) == ("query_train"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "i") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "d") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + query_train_handler(arguments[0], arguments[1]);
  } else if (((cmd) == ("release_train"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "i") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + release_train_handler(arguments[0]);
  } else if (((cmd) == ("delete_train"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "i") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + delete_train_handler(arguments[0]);
  } else if (((cmd) == ("add_train"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "i") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "n") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "m") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "s") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "p") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "x") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "t") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "o") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "d") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "y") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + add_train_handler(arguments[0], arguments[1],
                                        arguments[2], arguments[3],
                                        arguments[4], arguments[5],
                                        arguments[6], arguments[7],
                                        arguments[8], arguments[9]);
  } else if (((cmd) == ("modify_profile"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "c") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "p") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "n") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "m") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "g") values.push_back(v);
      assert(values.size() <= 1);
      if (!values.empty())
        arguments.push_back(values[0]);
      else
        arguments.push_back("");
    }
    return time_str + modify_profile_handler(arguments[0], arguments[1],
                                             arguments[2], arguments[3],
                                             arguments[4], arguments[5]);
  } else if (((cmd) == ("query_profile"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "c") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + query_profile_handler(arguments[0], arguments[1]);
  } else if (((cmd) == ("logout"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + logout_handler(arguments[0]);
  } else if (((cmd) == ("login"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "p") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + login_handler(arguments[0], arguments[1]);
  } else if (((cmd) == ("add_user"))) {
    sjtu::vector<std::string> arguments;
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "c") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "u") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "p") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "n") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "m") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    {
      sjtu::vector<std::string> values;
      for (auto &[k, v] : kvpair)
        if (k == "g") values.push_back(v);
      assert(values.size() == 1);
      arguments.push_back(values[0]);
    }
    return time_str + add_user_handler(arguments[0], arguments[1], arguments[2],
                                       arguments[3], arguments[4],
                                       arguments[5]);
  }

  return time_str + "unrecognized command!";
}
#endif
