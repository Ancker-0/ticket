/**
 * This file was generated by Chez Scheme
 * Generated at "Thu May 29 00:23:27 2025"
 *
 * 2025 © Coffish
 **/

#ifndef TYPEDECL_H
#define TYPEDECL_H

#include <cassert>
#include <cstdio>
#include <iostream>
#include <string>

#include "db/fs_vector.h"
#include "db/util.h"

const auto username_checker = ([](std::string s) {
  return (((((s).length()) <= (20))) && ((((s).length()) > (0))) && (({
            bool flag21 = true;
            for (auto &tmpvar22 : (s))
              if (not(({
                    bool flag23 = false;
                    for (auto &tmpvar24 : ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi"
                                           "jklmnopqrstuvwxyz0123456789_"))
                      if (((tmpvar22) == (tmpvar24))) {
                        flag23 = true;
                        break;
                      }
                    flag23;
                  }))) {
                flag21 = false;
                break;
              }
            flag21;
          })) &&
          (({
            bool flag19 = false;
            for (auto &tmpvar20 :
                 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"))
              if (((s[0]) == (tmpvar20))) {
                flag19 = true;
                break;
              }
            flag19;
          })));
});

const auto password_checker = ([](std::string s) {
  return (((((s).length()) <= (30))) && ((((s).length()) > (0))) && (({
            bool flag25 = true;
            for (auto &tmpvar26 : (s))
              if (not(({
                    bool flag27 = false;
                    for (auto &tmpvar28 :
                         ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
                          "0123456789|!\"#$%&´()*+,-./:;<=>?@[\\]^_`{}~"))
                      if (((tmpvar26) == (tmpvar28))) {
                        flag27 = true;
                        break;
                      }
                    flag27;
                  }))) {
                flag25 = false;
                break;
              }
            flag25;
          })));
});

static bool realname_checker(std::string s) {
  // TODO: check UTF8 hans character
  return 2 <= s.length() and s.length() <= 20 and true;
}

const auto mail_checker = ([](std::string s) {
  return (((((s).length()) <= (30))) && (({
            bool flag29 = true;
            for (auto &tmpvar30 : (s))
              if (not(({
                    bool flag31 = false;
                    for (auto &tmpvar32 : ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi"
                                           "jklmnopqrstuvwxyz0123456789@."))
                      if (((tmpvar30) == (tmpvar32))) {
                        flag31 = true;
                        break;
                      }
                    flag31;
                  }))) {
                flag29 = false;
                break;
              }
            flag29;
          })));
});

static bool privilege_checker(std::string s) {
  int x = string2non_negative(s);
  return 0 <= x and x <= 10;
}

const auto trainID_checker = ([](std::string s) {
  if ((((((s).length()) <= (20))) && (({
         bool flag35 = true;
         for (auto &tmpvar36 : (s))
           if (not(({
                 bool flag37 = false;
                 for (auto &tmpvar38 : ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijkl"
                                        "mnopqrstuvwxyz0123456789_"))
                   if (((tmpvar36) == (tmpvar38))) {
                     flag37 = true;
                     break;
                   }
                 flag37;
               }))) {
             flag35 = false;
             break;
           }
         flag35;
       })) &&
       (({
         bool flag33 = false;
         for (auto &tmpvar34 :
              ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"))
           if (((s[0]) == (tmpvar34))) {
             flag33 = true;
             break;
           }
         flag33;
       })))) {
    return true;
  } else {
    errf("Bad trainID %s\n", s.data());
    return true;
  }
});

const auto seatNum_checker = ([](std::string s) {
  return (((((s).length()) <= (6))) && (({
            bool flag39 = true;
            for (auto &tmpvar40 : (s))
              if (not(({
                    bool flag41 = false;
                    for (auto &tmpvar42 : ("0123456789"))
                      if (((tmpvar40) == (tmpvar42))) {
                        flag41 = true;
                        break;
                      }
                    flag41;
                  }))) {
                flag39 = false;
                break;
              }
            flag39;
          })) &&
          (((((0) <= (string2non_negative(s)))) &&
            (((string2non_negative(s)) <= (100000))))));
});

const auto stationName_checker =
    ([](std::string s) { return (((((s).length()) <= (40))) && (true)); });

const auto transferCode_checker =
    ([](std::string s) { return (((((s).length()) <= (80))) && (true)); });

// #define DF(n, len) using n##_t = cstr<len>;

using username_t = cstr<20>;

static username_t username_converter(std::string s) {
  assert(username_checker(s));
  return string2cstr<20>(s);
}
using password_t = cstr<30>;

static password_t password_converter(std::string s) {
  assert(password_checker(s));
  return string2cstr<30>(s);
}
using realname_t = cstr<20>;

static realname_t realname_converter(std::string s) {
  assert(realname_checker(s));
  return string2cstr<20>(s);
}
using mail_t = cstr<30>;

static mail_t mail_converter(std::string s) {
  assert(mail_checker(s));
  return string2cstr<30>(s);
}
using trainID_t = cstr<20>;

static trainID_t trainID_converter(std::string s) {
  assert(trainID_checker(s));
  return string2cstr<20>(s);
}
using stationName_t = cstr<40>;

static stationName_t stationName_converter(std::string s) {
  assert(stationName_checker(s));
  return string2cstr<40>(s);
}
using transferCode_t = cstr<80>;

static transferCode_t transferCode_converter(std::string s) {
  assert(transferCode_checker(s));
  return string2cstr<80>(s);
}

using privilege_t = int;
using stationNum_t = int;
using Time_t = int;
using price_t = int;
using duration_t = int;
using seatNum_t = int;
using date_t = __int8_t;
using train_type_t = char;
using time_and_date_t = std::pair<date_t, Time_t>;

static std::string date_printer(date_t d) {
  // Why there is a train running up to September...
  int mm = d < 30 ? 6 : d < 61 ? 7 : d < 92 ? 8 : d < 122 ? 9 : -1;
  int dd = 1 + (d < 30    ? d
                : d < 61  ? d - 30
                : d < 92  ? d - 61
                : d < 122 ? d - 92
                          : -1);
  static char buf[20];
  sprintf(buf, "%02d-%02d", mm, dd);
  return std::string(buf);
}

static std::string time_printer(Time_t d) {
  int hh = d / 60;
  int mm = d % 60;
  static char buf[20];
  sprintf(buf, "%02d:%02d", hh, mm);
  return std::string(buf);
}

static std::string time_and_date_printer(const time_and_date_t &x) {
  return date_printer(x.first) + " " + time_printer(x.second);
}

inline static int time_and_date_diff(const time_and_date_t &s,
                                     const time_and_date_t &t) {
  return (t.first - s.first) * 1440 + (t.second - s.second);
}

static time_and_date_t time_and_date_advance(time_and_date_t t,
                                             duration_t delta) {
  int min = t.second + delta;
  t.second = min % 1440;
  t.first += min / 1440;
  return t;
}

static bool time_and_date_less(time_and_date_t x, time_and_date_t y) {
  return x.first == y.first ? x.second < y.second : x.first < y.first;
}

const Time_t invalid_time = -1;
static Time_t Time_converter(std::string s) {
  if (not(s.size() == 5 and s[2] == ':')) return invalid_time;
  for (int i = 0; i < 5; ++i)
    if (i != 2 and not({
          bool flag63 = false;
          for (auto &tmpvar64 : ("0123456789"))
            if (((s[i]) == (tmpvar64))) {
              flag63 = true;
              break;
            }
          flag63;
        }))
      return invalid_time;
  return (s[0] - '0') * 600 + (s[1] - '0') * 60 + (s[3] - '0') * 10 +
         (s[4] - '0');
}

const auto Time_checker =
    ([](std::string s) { return (Time_converter(s) != invalid_time); });

const date_t invalid_date = -1;  // 0xFFFF
static date_t date_converter(std::string s) {
  if (not(s.size() == 5 and s[2] == '-')) return invalid_date;
  for (int i = 0; i < 5; ++i)
    if (i != 2 and not({
          bool flag65 = false;
          for (auto &tmpvar66 : ("0123456789"))
            if (((s[i]) == (tmpvar66))) {
              flag65 = true;
              break;
            }
          flag65;
        }))
      return invalid_date;
  date_t mm = (s[0] - '0') * 10 + s[1] - '0';
  date_t dd = (s[3] - '0') * 10 + s[4] - '0';
  if (not(((mm == 6 and dd <= 30) || (mm == 7 and dd <= 31) ||
           (mm == 8 and dd <= 31))))
    return invalid_date;
  return dd - 1 + (mm >= 7) * 30 + (mm >= 8) * 31;
}
const auto date_checker =
    ([](std::string s) { return date_converter(s) != invalid_date; });

struct user_profile {
  username_t username;
  password_t password;
  realname_t realname;
  mail_t mail;
  privilege_t privilege;

  fs_vector::Head invoices;

  user_profile() = default;
  user_profile(std::string s0, std::string s1, std::string s2, std::string s3,
               std::string s4) {
    assert(username_checker(s0));
    username = username_converter(s0);
    assert(password_checker(s1));
    password = password_converter(s1);
    assert(realname_checker(s2));
    realname = realname_converter(s2);
    assert(mail_checker(s3));
    mail = mail_converter(s3);
    assert(privilege_checker(s4));
    privilege = string2non_negative(s4);
    invoices = fs_vector::Head();
  }
  explicit operator std::string() {
    return (std::string)username + " " + (std::string)realname + " " +
           (std::string)mail + " " + number2string(privilege);
  }
};

struct train_t {
  // original field
  trainID_t trainID;
  stationNum_t stationNum;
  sjtu::array<stationName_t, 100> stationNames;
  seatNum_t seatNum;
  sjtu::array<price_t, 99> prices;
  Time_t startTime;
  sjtu::array<duration_t, 99> travelTimes;
  sjtu::array<duration_t, 98> stopoverTimes;
  date_t saleDate[2];
  train_type_t train_type;

  // additional field
  bool released;
  sjtu::array<sjtu::array<int, 99>, 92> seat;
  fs_vector::Head queue;
  int queue_head;

  train_t() = default;

  train_t(std::string s0, std::string s1, std::string s2, std::string s3,
          std::string s4, std::string s5, std::string s6, std::string s7,
          std::string s8, std::string s9) {
    assert(trainID_checker(s0));
    trainID = trainID_converter(s0);
    assert(([](std::string s) {
      return ((({
                bool flag55 = true;
                for (auto &tmpvar56 : (s))
                  if (not(({
                        bool flag57 = false;
                        for (auto &tmpvar58 : ("0123456789"))
                          if (((tmpvar56) == (tmpvar58))) {
                            flag57 = true;
                            break;
                          }
                        flag57;
                      }))) {
                    flag55 = false;
                    break;
                  }
                flag55;
              })) &&
              (string2non_negative(s) <= 100) && (string2non_negative(s) >= 2));
    })(s1));
    stationNum = string2non_negative(s1);
    auto tmpvar67 = split(s2);
    Eassert(tmpvar67.size() == (stationNum));
    for (size_t i = 0; i < tmpvar67.size(); ++i) {
      stationNames[i] = (stationName_converter(tmpvar67[i]));
    }
    assert(([](std::string s) {
      return ((({
                bool flag51 = true;
                for (auto &tmpvar52 : (s))
                  if (not(({
                        bool flag53 = false;
                        for (auto &tmpvar54 : ("0123456789"))
                          if (((tmpvar52) == (tmpvar54))) {
                            flag53 = true;
                            break;
                          }
                        flag53;
                      }))) {
                    flag51 = false;
                    break;
                  }
                flag51;
              })) &&
              (string2non_negative(s) <= 100000));
    })(s3));
    seatNum = string2non_negative(s3);
    auto tmpvar68 = split(s4);
    Eassert(tmpvar68.size() == (stationNum - 1));
    for (size_t i = 0; i < tmpvar68.size(); ++i) {
      prices[i] = (string2non_negative(tmpvar68[i]));
    }
    assert(Time_checker(s5));
    startTime = Time_converter(s5);
    auto tmpvar69 = split(s6);
    Eassert(tmpvar69.size() == (stationNum - 1));
    for (size_t i = 0; i < tmpvar69.size(); ++i) {
      travelTimes[i] = (string2non_negative(tmpvar69[i]));
    }
    auto tmpvar70 = split(s7);
    Eassert(tmpvar70.size() == (stationNum - 2));
    for (size_t i = 0; i < tmpvar70.size(); ++i) {
      stopoverTimes[i] = (string2non_negative(tmpvar70[i]));
    }
    auto tmpvar71 = split(s8);
    Eassert(tmpvar71.size() == (2));
    for (size_t i = 0; i < tmpvar71.size(); ++i) {
      saleDate[i] = (date_converter(tmpvar71[i]));
    }
    assert(([](std::string s) {
      return ({
        bool flag59 = true;
        for (auto &tmpvar60 : (s))
          if (not(({
                bool flag61 = false;
                for (auto &tmpvar62 : ("\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\""))
                  if (((tmpvar60) == (tmpvar62))) {
                    flag61 = true;
                    break;
                  }
                flag61;
              }))) {
            flag59 = false;
            break;
          }
        flag59;
      });
    })(s9));
    train_type = ([](std::string s) { return s[0]; })(s9);

    seat = decltype(seat)();
    released = false;
    queue = fs_vector::Head{};
    queue_head = 0;
  }

  int get_station_id(stationName_t name) const {
    for (int i = 0; i < stationNum; ++i)
      if (stationNames[i] == name) return i;
    return -1;
  }

  time_and_date_t arrive_time(int p) const {
    assert(~p);
    time_and_date_t ret = {0, startTime};
    for (int i = 0; i < p; ++i) {
      ret = time_and_date_advance(ret, travelTimes[i]);
      if (i > 0 and i < p)
        ret = time_and_date_advance(ret, stopoverTimes[i - 1]);
    }
    return ret;
  }

  time_and_date_t arrive_time(stationName_t name) const {
    return arrive_time(get_station_id(name));
  }

  time_and_date_t leaving_time(int p) const {
    assert(~p);
    time_and_date_t ret = arrive_time(p);
    return p ? time_and_date_advance(ret, stopoverTimes[p - 1]) : ret;
  }

  time_and_date_t leaving_time(stationName_t name) const {
    return leaving_time(get_station_id(name));
  }
};

inline static bool date_range(date_t x, date_t s, date_t t) {
  return s <= x and x <= t;
}

/*
int main() {
  std::string s;
  std::cin >> s;
  std::cout << username_checker(s) << std::endl;
  std::cout << password_checker(s) << std::endl;
  std::cout << mail_checker(s) << std::endl;
  return 0;
}
*/

#endif
